import fs from 'node:fs/promises'
import path from 'node:path'
import { fileURLToPath } from 'node:url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const repoRoot = path.resolve(__dirname, '..')

const resourcesPath = path.join(repoRoot, 'server', 'src', 'data', 'resources.json')
const outPath = path.join(repoRoot, 'acadiana_resources.md')
const fallbackModulePath = path.join(repoRoot, 'api', '_resourcesFallbackData.mjs')

function normalizeText(value) {
  if (value === null || value === undefined) return ''
  if (typeof value !== 'string') return String(value)
  return value.trim()
}

function escapeMd(value) {
  // Minimal escaping for list contexts; keep addresses readable.
  return value.replaceAll('\r\n', '\n').replaceAll('\r', '\n')
}

function titleCase(value) {
  const text = normalizeText(value)
  if (!text) return ''
  return text
    .split(/[-_\s]+/g)
    .filter(Boolean)
    .map(w => w.charAt(0).toUpperCase() + w.slice(1))
    .join(' ')
}

function sortKey(resource) {
  return [
    normalizeText(resource.parish),
    normalizeText(resource.categoryLabel || resource.category),
    normalizeText(resource.name),
  ].join('\u0000')
}

function renderResource(resource) {
  const name = normalizeText(resource.name)
  const categoryLabel = normalizeText(resource.categoryLabel || titleCase(resource.category))
  const parish = normalizeText(resource.parish)

  const lines = []
  lines.push(`### ${escapeMd(name)}`)
  lines.push('')
  lines.push(`- Category: ${escapeMd(categoryLabel)}`)
  lines.push(`- Parish: ${escapeMd(titleCase(parish))}`)

  if (resource.phone) lines.push(`- Phone: ${escapeMd(normalizeText(resource.phone))}`)
  if (resource.address) lines.push(`- Address: ${escapeMd(normalizeText(resource.address))}`)
  if (resource.hours) lines.push(`- Hours: ${escapeMd(normalizeText(resource.hours))}`)

  if (resource.description) {
    lines.push(`- Description: ${escapeMd(normalizeText(resource.description))}`)
  }
  if (resource.eligibility) {
    lines.push(`- Eligibility: ${escapeMd(normalizeText(resource.eligibility))}`)
  }
  if (resource.nextStep) {
    lines.push(`- Next step: ${escapeMd(normalizeText(resource.nextStep))}`)
  }
  if (resource.verified) {
    lines.push(`- Verified in app: ${escapeMd(normalizeText(resource.verified))}`)
  }

  lines.push('')
  return lines.join('\n')
}

async function main() {
  const raw = await fs.readFile(resourcesPath, 'utf-8')
  const resources = JSON.parse(raw)

  if (!Array.isArray(resources)) {
    throw new Error('Expected resources.json to be an array')
  }

  const sorted = [...resources].sort((a, b) => sortKey(a).localeCompare(sortKey(b)))
  const generatedOn = new Date().toISOString().slice(0, 10)

  const parishes = Array.from(new Set(sorted.map(r => normalizeText(r.parish)).filter(Boolean)))
    .sort((a, b) => a.localeCompare(b))

  const lines = []
  lines.push('# Acadiana Local Resources (Compiled in Bayou Help)')
  lines.push('')
  lines.push(`Generated: ${generatedOn}`)
  lines.push('')
  lines.push('This document is generated from the app’s bundled dataset in `server/src/data/resources.json`.')
  lines.push('To maintain strict accuracy, it lists only the contact/location info present in the repository (no additional web research was used).')
  lines.push('')
  lines.push('## Quick Notes')
  lines.push('')
  lines.push('- Websites/emails are not included because they are not present in the dataset.')
  lines.push('- Some services list “Confidential” addresses or are phone/text-only by design.')
  lines.push('')

  lines.push('## Parishes Included')
  lines.push('')
  for (const parish of parishes) {
    lines.push(`- ${titleCase(parish)}`)
  }
  lines.push('')

  // Group by parish for readability
  for (const parish of parishes) {
    const group = sorted.filter(r => normalizeText(r.parish) === parish)
    lines.push(`## ${titleCase(parish)} Parish`) // dataset uses parish codes, but these are parishes
    lines.push('')

    // Group within parish by categoryLabel
    const categories = Array.from(
      new Set(group.map(r => normalizeText(r.categoryLabel || titleCase(r.category))).filter(Boolean))
    ).sort((a, b) => a.localeCompare(b))

    for (const categoryLabel of categories) {
      lines.push(`### ${escapeMd(categoryLabel)}`)
      lines.push('')

      const resourcesInCategory = group
        .filter(r => normalizeText(r.categoryLabel || titleCase(r.category)) === categoryLabel)
        .sort((a, b) => normalizeText(a.name).localeCompare(normalizeText(b.name)))

      for (const resource of resourcesInCategory) {
        lines.push(renderResource(resource))
      }
    }
  }

  await fs.writeFile(outPath, lines.join('\n'), 'utf-8')

  const moduleContents = [
    '// This file is generated by scripts/generate-acadiana-resources.mjs',
    `export const GENERATED_ON = ${JSON.stringify(generatedOn)};`,
    `export const RESOURCES_FALLBACK = ${JSON.stringify(sorted, null, 2)};`,
    '',
  ].join('\n')

  await fs.writeFile(fallbackModulePath, moduleContents, 'utf-8')

  console.log(`Wrote ${outPath} (${sorted.length} resources)`)
  console.log(`Wrote ${fallbackModulePath} (${sorted.length} resources)`)
}

main().catch((err) => {
  console.error(err)
  process.exitCode = 1
})
